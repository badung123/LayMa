//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const ADMIN_API_BASE_URL = new InjectionToken<string>('ADMIN_API_BASE_URL');

@Injectable()
export class AdminApiAuthApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body?: LoginRequest | undefined): Observable<AuthenticatedResult> {
        let url_ = this.baseUrl + "/api/admin/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticatedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticatedResult>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthenticatedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegisterRequest | undefined): Observable<RegistrationResponse> {
        let url_ = this.baseUrl + "/api/admin/auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegistrationResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegistrationResponse>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegistrationResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegistrationResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    forgotPassword(body?: ForgotPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/auth/forgotPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/auth/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNotiSetting(): Observable<NotiSettings[]> {
        let url_ = this.baseUrl + "/api/admin/auth/getNoti";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotiSetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotiSetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NotiSettings[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NotiSettings[]>;
        }));
    }

    protected processGetNotiSetting(response: HttpResponseBase): Observable<NotiSettings[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NotiSettings.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiBankTransactionApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createBankTransaction(body?: CreateBankTransactionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/banktransaction/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBankTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBankTransaction(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateBankTransaction(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getPostsPaging(pageIndex?: number | undefined, pageSize?: number | undefined, keySearch?: string | null | undefined): Observable<BankTransactionInListDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/banktransaction/paging?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankTransactionInListDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankTransactionInListDtoPagedResult>;
        }));
    }

    protected processGetPostsPaging(response: HttpResponseBase): Observable<BankTransactionInListDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankTransactionInListDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getAllPaging(pageIndex?: number | undefined, pageSize?: number | undefined, keySearch?: string | null | undefined): Observable<BankTransactionInListDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/banktransaction/allpaging?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BankTransactionInListDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BankTransactionInListDtoPagedResult>;
        }));
    }

    protected processGetAllPaging(response: HttpResponseBase): Observable<BankTransactionInListDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = BankTransactionInListDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProcessStatus(body?: UpdateStatusRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/banktransaction/updateprocess";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProcessStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProcessStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProcessStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiCampainApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateCampain(body?: CreateOrUpdateCampainRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/campain";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateCampain(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateCampain(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateCampain(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param keytoken (optional) 
     * @return Success
     */
    getCampainByKeyToken(keytoken?: string | null | undefined): Observable<CampainDto> {
        let url_ = this.baseUrl + "/api/admin/campain?";
        if (keytoken !== undefined && keytoken !== null)
            url_ += "keytoken=" + encodeURIComponent("" + keytoken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampainByKeyToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampainByKeyToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CampainDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CampainDto>;
        }));
    }

    protected processGetCampainByKeyToken(response: HttpResponseBase): Observable<CampainDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampainDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param campainId (optional) 
     * @return Success
     */
    getCampainByCampainId(campainId?: string | undefined): Observable<CampainInListDto> {
        let url_ = this.baseUrl + "/api/admin/campain/getCampainByCampainId?";
        if (campainId === null)
            throw new Error("The parameter 'campainId' cannot be null.");
        else if (campainId !== undefined)
            url_ += "campainId=" + encodeURIComponent("" + campainId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCampainByCampainId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCampainByCampainId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CampainInListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CampainInListDto>;
        }));
    }

    protected processGetCampainByCampainId(response: HttpResponseBase): Observable<CampainInListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampainInListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getThongKeView(): Observable<ThongKeView> {
        let url_ = this.baseUrl + "/api/admin/campain/thongkeview";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThongKeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThongKeView>;
        }));
    }

    protected processGetThongKeView(response: HttpResponseBase): Observable<ThongKeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongKeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param flatform (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getPostsPaging2(pageIndex?: number | undefined, pageSize?: number | undefined, flatform?: string | null | undefined, keySearch?: string | null | undefined): Observable<CampainInListDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/campain/paging?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (flatform !== undefined && flatform !== null)
            url_ += "flatform=" + encodeURIComponent("" + flatform) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsPaging2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsPaging2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CampainInListDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CampainInListDtoPagedResult>;
        }));
    }

    protected processGetPostsPaging2(response: HttpResponseBase): Observable<CampainInListDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CampainInListDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiCodeManagerApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createCode(body?: InsertCodeRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/codemanager/createcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    checkCode(body?: CheckCodeRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/codemanager/checkcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCheckCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getCode(body?: { [key: string]: any; } | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/admin/codemanager/getcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetCode(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiKeySearchApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getInfoKeySeoRandom(): Observable<KeySeoDto> {
        let url_ = this.baseUrl + "/api/admin/keyseo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoKeySeoRandom(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoKeySeoRandom(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<KeySeoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<KeySeoDto>;
        }));
    }

    protected processGetInfoKeySeoRandom(response: HttpResponseBase): Observable<KeySeoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = KeySeoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getThongKeView2(): Observable<ThongKeView> {
        let url_ = this.baseUrl + "/api/admin/keyseo/thongkeview";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeView2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeView2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThongKeView>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThongKeView>;
        }));
    }

    protected processGetThongKeView2(response: HttpResponseBase): Observable<ThongKeView> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongKeView.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiMediaApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param type (optional) 
     * @return Success
     */
    uploadImage(type?: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/media?";
        if (type !== undefined && type !== null)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiMissionApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param token (optional) 
     * @return Success
     */
    getMissionByTokenShortLink(token?: string | null | undefined): Observable<MissionDto> {
        let url_ = this.baseUrl + "/api/admin/mission?";
        if (token !== undefined && token !== null)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMissionByTokenShortLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMissionByTokenShortLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MissionDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MissionDto>;
        }));
    }

    protected processGetMissionByTokenShortLink(response: HttpResponseBase): Observable<MissionDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = MissionDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeMission(body?: ChangeMissionRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/mission/changeMission";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeMission(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeMission(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeMission(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiShortLinkApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createShortLink(body?: CreateShortLinkDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/shortlink/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateShortLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateShortLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateShortLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getPostsPaging3(pageIndex?: number | undefined, pageSize?: number | undefined, keySearch?: string | null | undefined): Observable<ShortLinkInListDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/shortlink/paging?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostsPaging3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostsPaging3(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortLinkInListDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortLinkInListDtoPagedResult>;
        }));
    }

    protected processGetPostsPaging3(response: HttpResponseBase): Observable<ShortLinkInListDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShortLinkInListDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTopLink(): Observable<ShortLinkInListDto[]> {
        let url_ = this.baseUrl + "/api/admin/shortlink/gettop";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ShortLinkInListDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ShortLinkInListDto[]>;
        }));
    }

    protected processGetTopLink(response: HttpResponseBase): Observable<ShortLinkInListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ShortLinkInListDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getBalance(): Observable<number> {
        let url_ = this.baseUrl + "/api/admin/shortlink/getbalance";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBalance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBalance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetBalance(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param from (optional) 
     * @param to (optional) 
     * @return Success
     */
    getThongKeClickByDate(from?: Date | undefined, to?: Date | undefined): Observable<ThongKeViewClick> {
        let url_ = this.baseUrl + "/api/admin/shortlink/thongkeClickByDate?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetThongKeClickByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetThongKeClickByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThongKeViewClick>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThongKeViewClick>;
        }));
    }

    protected processGetThongKeClickByDate(response: HttpResponseBase): Observable<ThongKeViewClick> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ThongKeViewClick.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    thongkeAllClickInDay(): Observable<number> {
        let url_ = this.baseUrl + "/api/admin/shortlink/thongkeAllClickInDay";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processThongkeAllClickInDay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processThongkeAllClickInDay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processThongkeAllClickInDay(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNguon(body?: UpdateNguon | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/shortlink/updateNguon";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNguon(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNguon(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNguon(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param from (optional) 
     * @param to (optional) 
     * @return Success
     */
    getHoaHongByDate(from?: Date | undefined, to?: Date | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/admin/shortlink/gethoahongbydate?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHoaHongByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHoaHongByDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetHoaHongByDate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param from (optional) 
     * @param to (optional) 
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param userName (optional) 
     * @param type (optional) 
     * @param userAgent (optional) 
     * @param shortLink (optional) 
     * @param screen (optional) 
     * @param ip (optional) 
     * @param flatform (optional) 
     * @return Success
     */
    getLogShortLinkPaging(from?: Date | undefined, to?: Date | undefined, pageIndex?: number | undefined, pageSize?: number | undefined, userName?: string | null | undefined, type?: number | undefined, userAgent?: string | null | undefined, shortLink?: string | null | undefined, screen?: string | null | undefined, ip?: string | null | undefined, flatform?: string | null | undefined): Observable<LogShortLinkDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/shortlink/paging-log-shortlink?";
        if (from === null)
            throw new Error("The parameter 'from' cannot be null.");
        else if (from !== undefined)
            url_ += "from=" + encodeURIComponent(from ? "" + from.toISOString() : "") + "&";
        if (to === null)
            throw new Error("The parameter 'to' cannot be null.");
        else if (to !== undefined)
            url_ += "to=" + encodeURIComponent(to ? "" + to.toISOString() : "") + "&";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (userName !== undefined && userName !== null)
            url_ += "userName=" + encodeURIComponent("" + userName) + "&";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&";
        if (userAgent !== undefined && userAgent !== null)
            url_ += "userAgent=" + encodeURIComponent("" + userAgent) + "&";
        if (shortLink !== undefined && shortLink !== null)
            url_ += "shortLink=" + encodeURIComponent("" + shortLink) + "&";
        if (screen !== undefined && screen !== null)
            url_ += "screen=" + encodeURIComponent("" + screen) + "&";
        if (ip !== undefined && ip !== null)
            url_ += "ip=" + encodeURIComponent("" + ip) + "&";
        if (flatform !== undefined && flatform !== null)
            url_ += "flatform=" + encodeURIComponent("" + flatform) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLogShortLinkPaging(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLogShortLinkPaging(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LogShortLinkDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LogShortLinkDtoPagedResult>;
        }));
    }

    protected processGetLogShortLinkPaging(response: HttpResponseBase): Observable<LogShortLinkDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LogShortLinkDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiTestApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    testAuthen(): Observable<void> {
        let url_ = this.baseUrl + "/api/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestAuthen(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestAuthen(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestAuthen(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiTokenApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refresh(body?: TokenRequest | undefined): Observable<AuthenticatedResult> {
        let url_ = this.baseUrl + "/api/admin/token/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticatedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticatedResult>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<AuthenticatedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    revoke(): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/token/revoke";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRevoke(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRevoke(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRevoke(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiUserApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyUser(body?: VerifyUserRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/user/addVerify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifyUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyUserByAdmin(body?: VerifyOrLockUserRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/user/adminVerify";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyUserByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyUserByAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifyUserByAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    lockUserByAdmin(body?: VerifyOrLockUserRequest | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/admin/user/adminlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockUserByAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockUserByAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLockUserByAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getInfoVerify(): Observable<VerifyUserInfo> {
        let url_ = this.baseUrl + "/api/admin/user/getInfoVerify";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInfoVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInfoVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerifyUserInfo>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerifyUserInfo>;
        }));
    }

    protected processGetInfoVerify(response: HttpResponseBase): Observable<VerifyUserInfo> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = VerifyUserInfo.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getListAgentByUserId(pageIndex?: number | undefined, pageSize?: number | undefined, keySearch?: string | null | undefined): Observable<AgentListDtoPagedResult> {
        let url_ = this.baseUrl + "/api/admin/user/getListAgentByUserId?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListAgentByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListAgentByUserId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AgentListDtoPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AgentListDtoPagedResult>;
        }));
    }

    protected processGetListAgentByUserId(response: HttpResponseBase): Observable<AgentListDtoPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AgentListDtoPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageIndex (optional) 
     * @param pageSize (optional) 
     * @param keySearch (optional) 
     * @return Success
     */
    getListUser(pageIndex?: number | undefined, pageSize?: number | undefined, keySearch?: string | null | undefined): Observable<UserDtoInListPagedResult> {
        let url_ = this.baseUrl + "/api/admin/user/GetListUser?";
        if (pageIndex === null)
            throw new Error("The parameter 'pageIndex' cannot be null.");
        else if (pageIndex !== undefined)
            url_ += "pageIndex=" + encodeURIComponent("" + pageIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (keySearch !== undefined && keySearch !== null)
            url_ += "keySearch=" + encodeURIComponent("" + keySearch) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDtoInListPagedResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDtoInListPagedResult>;
        }));
    }

    protected processGetListUser(response: HttpResponseBase): Observable<UserDtoInListPagedResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDtoInListPagedResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdminApiVisitorApiClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(ADMIN_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    saveVisitor(body?: { [key: string]: any; } | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/admin/visitor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveVisitor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveVisitor(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processSaveVisitor(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class AgentListDto implements IAgentListDto {
    memberId?: string;
    userName?: string | undefined;
    dateCreated?: Date;
    isActive?: boolean;
    isVerify?: boolean;

    constructor(data?: IAgentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.memberId = _data["memberId"];
            this.userName = _data["userName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
            this.isVerify = _data["isVerify"];
        }
    }

    static fromJS(data: any): AgentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["memberId"] = this.memberId;
        data["userName"] = this.userName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["isVerify"] = this.isVerify;
        return data;
    }
}

export interface IAgentListDto {
    memberId?: string;
    userName?: string | undefined;
    dateCreated?: Date;
    isActive?: boolean;
    isVerify?: boolean;
}

export class AgentListDtoPagedResult implements IAgentListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: AgentListDto[] | undefined;

    constructor(data?: IAgentListDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(AgentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AgentListDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new AgentListDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAgentListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: AgentListDto[] | undefined;
}

export class AuthenticatedResult implements IAuthenticatedResult {
    token?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IAuthenticatedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticatedResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IAuthenticatedResult {
    token?: string | undefined;
    refreshToken?: string | undefined;
}

export class BankTransactionInListDto implements IBankTransactionInListDto {
    id?: string;
    userId?: string;
    userName?: string | undefined;
    money?: number;
    statusProcess?: ProcessStatus;
    bankAccountName?: string | undefined;
    bankAccountNumber?: string | undefined;
    bankName?: string | undefined;
    dateCreated?: Date;
    dateModified?: Date | undefined;

    constructor(data?: IBankTransactionInListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.money = _data["money"];
            this.statusProcess = _data["statusProcess"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BankTransactionInListDto {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransactionInListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["money"] = this.money;
        data["statusProcess"] = this.statusProcess;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBankTransactionInListDto {
    id?: string;
    userId?: string;
    userName?: string | undefined;
    money?: number;
    statusProcess?: ProcessStatus;
    bankAccountName?: string | undefined;
    bankAccountNumber?: string | undefined;
    bankName?: string | undefined;
    dateCreated?: Date;
    dateModified?: Date | undefined;
}

export class BankTransactionInListDtoPagedResult implements IBankTransactionInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: BankTransactionInListDto[] | undefined;

    constructor(data?: IBankTransactionInListDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(BankTransactionInListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BankTransactionInListDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new BankTransactionInListDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBankTransactionInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: BankTransactionInListDto[] | undefined;
}

export class CampainDto implements ICampainDto {
    id?: string;
    keyToken?: string | undefined;
    flatform?: string | undefined;
    timeOnSitePerView?: number;

    constructor(data?: ICampainDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keyToken = _data["keyToken"];
            this.flatform = _data["flatform"];
            this.timeOnSitePerView = _data["timeOnSitePerView"];
        }
    }

    static fromJS(data: any): CampainDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampainDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keyToken"] = this.keyToken;
        data["flatform"] = this.flatform;
        data["timeOnSitePerView"] = this.timeOnSitePerView;
        return data;
    }
}

export interface ICampainDto {
    id?: string;
    keyToken?: string | undefined;
    flatform?: string | undefined;
    timeOnSitePerView?: number;
}

export class CampainInListDto implements ICampainInListDto {
    id?: string;
    keySearch?: string | undefined;
    keyToken?: string | undefined;
    flatform?: string | undefined;
    imageUrl?: string | undefined;
    decription?: string | undefined;
    url?: string | undefined;
    viewPerDay?: number;
    toTalView?: number;
    pricePerView?: number;
    timeOnSitePerView?: number;
    status?: boolean;
    dateCreated?: Date;
    dateModified?: Date | undefined;

    constructor(data?: ICampainInListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.keySearch = _data["keySearch"];
            this.keyToken = _data["keyToken"];
            this.flatform = _data["flatform"];
            this.imageUrl = _data["imageUrl"];
            this.decription = _data["decription"];
            this.url = _data["url"];
            this.viewPerDay = _data["viewPerDay"];
            this.toTalView = _data["toTalView"];
            this.pricePerView = _data["pricePerView"];
            this.timeOnSitePerView = _data["timeOnSitePerView"];
            this.status = _data["status"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CampainInListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CampainInListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["keySearch"] = this.keySearch;
        data["keyToken"] = this.keyToken;
        data["flatform"] = this.flatform;
        data["imageUrl"] = this.imageUrl;
        data["decription"] = this.decription;
        data["url"] = this.url;
        data["viewPerDay"] = this.viewPerDay;
        data["toTalView"] = this.toTalView;
        data["pricePerView"] = this.pricePerView;
        data["timeOnSitePerView"] = this.timeOnSitePerView;
        data["status"] = this.status;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface ICampainInListDto {
    id?: string;
    keySearch?: string | undefined;
    keyToken?: string | undefined;
    flatform?: string | undefined;
    imageUrl?: string | undefined;
    decription?: string | undefined;
    url?: string | undefined;
    viewPerDay?: number;
    toTalView?: number;
    pricePerView?: number;
    timeOnSitePerView?: number;
    status?: boolean;
    dateCreated?: Date;
    dateModified?: Date | undefined;
}

export class CampainInListDtoPagedResult implements ICampainInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: CampainInListDto[] | undefined;

    constructor(data?: ICampainInListDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(CampainInListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CampainInListDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new CampainInListDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICampainInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: CampainInListDto[] | undefined;
}

export class ChangeMissionRequest implements IChangeMissionRequest {
    token?: string | undefined;

    constructor(data?: IChangeMissionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): ChangeMissionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeMissionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data;
    }
}

export interface IChangeMissionRequest {
    token?: string | undefined;
}

export class CheckCodeRequest implements ICheckCodeRequest {
    code?: string | undefined;
    token?: string | undefined;
    campainId?: string | undefined;
    deviceScreen?: string | undefined;
    userAgent?: string | undefined;

    constructor(data?: ICheckCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.token = _data["token"];
            this.campainId = _data["campainId"];
            this.deviceScreen = _data["deviceScreen"];
            this.userAgent = _data["userAgent"];
        }
    }

    static fromJS(data: any): CheckCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CheckCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["token"] = this.token;
        data["campainId"] = this.campainId;
        data["deviceScreen"] = this.deviceScreen;
        data["userAgent"] = this.userAgent;
        return data;
    }
}

export interface ICheckCodeRequest {
    code?: string | undefined;
    token?: string | undefined;
    campainId?: string | undefined;
    deviceScreen?: string | undefined;
    userAgent?: string | undefined;
}

export class CreateBankTransactionDto implements ICreateBankTransactionDto {
    money?: number;
    bankAccountName?: string | undefined;
    bankAccountNumber?: string | undefined;
    bankName?: string | undefined;

    constructor(data?: ICreateBankTransactionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.money = _data["money"];
            this.bankAccountName = _data["bankAccountName"];
            this.bankAccountNumber = _data["bankAccountNumber"];
            this.bankName = _data["bankName"];
        }
    }

    static fromJS(data: any): CreateBankTransactionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateBankTransactionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["money"] = this.money;
        data["bankAccountName"] = this.bankAccountName;
        data["bankAccountNumber"] = this.bankAccountNumber;
        data["bankName"] = this.bankName;
        return data;
    }
}

export interface ICreateBankTransactionDto {
    money?: number;
    bankAccountName?: string | undefined;
    bankAccountNumber?: string | undefined;
    bankName?: string | undefined;
}

export class CreateOrUpdateCampainRequest implements ICreateOrUpdateCampainRequest {
    campainId?: string;
    key?: string | undefined;
    urlWeb?: string | undefined;
    thumbnail?: string | undefined;
    price?: number;
    time?: number;
    view?: number;
    flatform?: string | undefined;

    constructor(data?: ICreateOrUpdateCampainRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.campainId = _data["campainId"];
            this.key = _data["key"];
            this.urlWeb = _data["urlWeb"];
            this.thumbnail = _data["thumbnail"];
            this.price = _data["price"];
            this.time = _data["time"];
            this.view = _data["view"];
            this.flatform = _data["flatform"];
        }
    }

    static fromJS(data: any): CreateOrUpdateCampainRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateCampainRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["campainId"] = this.campainId;
        data["key"] = this.key;
        data["urlWeb"] = this.urlWeb;
        data["thumbnail"] = this.thumbnail;
        data["price"] = this.price;
        data["time"] = this.time;
        data["view"] = this.view;
        data["flatform"] = this.flatform;
        return data;
    }
}

export interface ICreateOrUpdateCampainRequest {
    campainId?: string;
    key?: string | undefined;
    urlWeb?: string | undefined;
    thumbnail?: string | undefined;
    price?: number;
    time?: number;
    view?: number;
    flatform?: string | undefined;
}

export class CreateShortLinkDto implements ICreateShortLinkDto {
    url?: string | undefined;

    constructor(data?: ICreateShortLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.url = _data["url"];
        }
    }

    static fromJS(data: any): CreateShortLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateShortLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["url"] = this.url;
        return data;
    }
}

export interface ICreateShortLinkDto {
    url?: string | undefined;
}

export class ForgotPasswordRequest implements IForgotPasswordRequest {
    email?: string | undefined;

    constructor(data?: IForgotPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data;
    }
}

export interface IForgotPasswordRequest {
    email?: string | undefined;
}

export class InsertCodeRequest implements IInsertCodeRequest {
    key?: string | undefined;
    code?: string | undefined;

    constructor(data?: IInsertCodeRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): InsertCodeRequest {
        data = typeof data === 'object' ? data : {};
        let result = new InsertCodeRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["code"] = this.code;
        return data;
    }
}

export interface IInsertCodeRequest {
    key?: string | undefined;
    code?: string | undefined;
}

export class KeySeoDto implements IKeySeoDto {
    id?: string;
    key?: string | undefined;
    maxViewDay?: number;
    viewedInDay?: number;
    urlImage?: string | undefined;
    urlWeb?: string | undefined;
    urlVideo?: string | undefined;

    constructor(data?: IKeySeoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.maxViewDay = _data["maxViewDay"];
            this.viewedInDay = _data["viewedInDay"];
            this.urlImage = _data["urlImage"];
            this.urlWeb = _data["urlWeb"];
            this.urlVideo = _data["urlVideo"];
        }
    }

    static fromJS(data: any): KeySeoDto {
        data = typeof data === 'object' ? data : {};
        let result = new KeySeoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["maxViewDay"] = this.maxViewDay;
        data["viewedInDay"] = this.viewedInDay;
        data["urlImage"] = this.urlImage;
        data["urlWeb"] = this.urlWeb;
        data["urlVideo"] = this.urlVideo;
        return data;
    }
}

export interface IKeySeoDto {
    id?: string;
    key?: string | undefined;
    maxViewDay?: number;
    viewedInDay?: number;
    urlImage?: string | undefined;
    urlWeb?: string | undefined;
    urlVideo?: string | undefined;
}

export class LogShortLinkDto implements ILogShortLinkDto {
    id?: string;
    userId?: string;
    userName?: string | undefined;
    oldBalance?: number;
    amount?: number;
    description?: string | undefined;
    createdBy?: string | undefined;
    deviceScreen?: string | undefined;
    userAgent?: string | undefined;
    ipAddress?: string | undefined;
    shortLink?: string | undefined;
    tranSactionType?: TranSactionType;
    dateCreated?: Date;
    dateModified?: Date | undefined;
    flatform?: string | undefined;

    constructor(data?: ILogShortLinkDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.oldBalance = _data["oldBalance"];
            this.amount = _data["amount"];
            this.description = _data["description"];
            this.createdBy = _data["createdBy"];
            this.deviceScreen = _data["deviceScreen"];
            this.userAgent = _data["userAgent"];
            this.ipAddress = _data["ipAddress"];
            this.shortLink = _data["shortLink"];
            this.tranSactionType = _data["tranSactionType"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
            this.flatform = _data["flatform"];
        }
    }

    static fromJS(data: any): LogShortLinkDto {
        data = typeof data === 'object' ? data : {};
        let result = new LogShortLinkDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["oldBalance"] = this.oldBalance;
        data["amount"] = this.amount;
        data["description"] = this.description;
        data["createdBy"] = this.createdBy;
        data["deviceScreen"] = this.deviceScreen;
        data["userAgent"] = this.userAgent;
        data["ipAddress"] = this.ipAddress;
        data["shortLink"] = this.shortLink;
        data["tranSactionType"] = this.tranSactionType;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        data["flatform"] = this.flatform;
        return data;
    }
}

export interface ILogShortLinkDto {
    id?: string;
    userId?: string;
    userName?: string | undefined;
    oldBalance?: number;
    amount?: number;
    description?: string | undefined;
    createdBy?: string | undefined;
    deviceScreen?: string | undefined;
    userAgent?: string | undefined;
    ipAddress?: string | undefined;
    shortLink?: string | undefined;
    tranSactionType?: TranSactionType;
    dateCreated?: Date;
    dateModified?: Date | undefined;
    flatform?: string | undefined;
}

export class LogShortLinkDtoPagedResult implements ILogShortLinkDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: LogShortLinkDto[] | undefined;

    constructor(data?: ILogShortLinkDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(LogShortLinkDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LogShortLinkDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new LogShortLinkDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILogShortLinkDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: LogShortLinkDto[] | undefined;
}

export class LoginRequest implements ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginRequest {
        data = typeof data === 'object' ? data : {};
        let result = new LoginRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginRequest {
    userName?: string | undefined;
    password?: string | undefined;
}

export class MissionDto implements IMissionDto {
    id?: string;
    key?: string | undefined;
    urlImage?: string | undefined;
    urlWeb?: string | undefined;
    urlVideo?: string | undefined;
    flatfrom?: string | undefined;
    urlFacebook?: string | undefined;
    campainId?: string;
    isHetMa?: boolean;
    linkDuPhong?: string | undefined;

    constructor(data?: IMissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.key = _data["key"];
            this.urlImage = _data["urlImage"];
            this.urlWeb = _data["urlWeb"];
            this.urlVideo = _data["urlVideo"];
            this.flatfrom = _data["flatfrom"];
            this.urlFacebook = _data["urlFacebook"];
            this.campainId = _data["campainId"];
            this.isHetMa = _data["isHetMa"];
            this.linkDuPhong = _data["linkDuPhong"];
        }
    }

    static fromJS(data: any): MissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["key"] = this.key;
        data["urlImage"] = this.urlImage;
        data["urlWeb"] = this.urlWeb;
        data["urlVideo"] = this.urlVideo;
        data["flatfrom"] = this.flatfrom;
        data["urlFacebook"] = this.urlFacebook;
        data["campainId"] = this.campainId;
        data["isHetMa"] = this.isHetMa;
        data["linkDuPhong"] = this.linkDuPhong;
        return data;
    }
}

export interface IMissionDto {
    id?: string;
    key?: string | undefined;
    urlImage?: string | undefined;
    urlWeb?: string | undefined;
    urlVideo?: string | undefined;
    flatfrom?: string | undefined;
    urlFacebook?: string | undefined;
    campainId?: string;
    isHetMa?: boolean;
    linkDuPhong?: string | undefined;
}

export class NotiSettings implements INotiSettings {
    severity?: string | undefined;
    detail?: string | undefined;

    constructor(data?: INotiSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.severity = _data["severity"];
            this.detail = _data["detail"];
        }
    }

    static fromJS(data: any): NotiSettings {
        data = typeof data === 'object' ? data : {};
        let result = new NotiSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["severity"] = this.severity;
        data["detail"] = this.detail;
        return data;
    }
}

export interface INotiSettings {
    severity?: string | undefined;
    detail?: string | undefined;
}

export enum ProcessStatus {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class RegisterRequest implements IRegisterRequest {
    userName?: string | undefined;
    email?: string | undefined;
    refcode?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;

    constructor(data?: IRegisterRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.refcode = _data["refcode"];
            this.password = _data["password"];
            this.confirmPassword = _data["confirmPassword"];
        }
    }

    static fromJS(data: any): RegisterRequest {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["refcode"] = this.refcode;
        data["password"] = this.password;
        data["confirmPassword"] = this.confirmPassword;
        return data;
    }
}

export interface IRegisterRequest {
    userName?: string | undefined;
    email?: string | undefined;
    refcode?: string | undefined;
    password?: string | undefined;
    confirmPassword?: string | undefined;
}

export class RegistrationResponse implements IRegistrationResponse {
    isSuccessful?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IRegistrationResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccessful = _data["isSuccessful"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): RegistrationResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RegistrationResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccessful"] = this.isSuccessful;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data;
    }
}

export interface IRegistrationResponse {
    isSuccessful?: boolean;
    errors?: string[] | undefined;
}

export class ResetPasswordRequest implements IResetPasswordRequest {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;

    constructor(data?: IResetPasswordRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPasswordRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        return data;
    }
}

export interface IResetPasswordRequest {
    email?: string | undefined;
    token?: string | undefined;
    password?: string | undefined;
}

export class ShortLinkInListDto implements IShortLinkInListDto {
    id?: string;
    link?: string | undefined;
    originLink?: string | undefined;
    origin?: string | undefined;
    duphong?: string | undefined;
    viewCount?: number;
    token?: string | undefined;
    dateCreated?: Date;
    dateModified?: Date | undefined;

    constructor(data?: IShortLinkInListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.link = _data["link"];
            this.originLink = _data["originLink"];
            this.origin = _data["origin"];
            this.duphong = _data["duphong"];
            this.viewCount = _data["viewCount"];
            this.token = _data["token"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.dateModified = _data["dateModified"] ? new Date(_data["dateModified"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ShortLinkInListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShortLinkInListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["link"] = this.link;
        data["originLink"] = this.originLink;
        data["origin"] = this.origin;
        data["duphong"] = this.duphong;
        data["viewCount"] = this.viewCount;
        data["token"] = this.token;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["dateModified"] = this.dateModified ? this.dateModified.toISOString() : <any>undefined;
        return data;
    }
}

export interface IShortLinkInListDto {
    id?: string;
    link?: string | undefined;
    originLink?: string | undefined;
    origin?: string | undefined;
    duphong?: string | undefined;
    viewCount?: number;
    token?: string | undefined;
    dateCreated?: Date;
    dateModified?: Date | undefined;
}

export class ShortLinkInListDtoPagedResult implements IShortLinkInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: ShortLinkInListDto[] | undefined;

    constructor(data?: IShortLinkInListDtoPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ShortLinkInListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ShortLinkInListDtoPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new ShortLinkInListDtoPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IShortLinkInListDtoPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: ShortLinkInListDto[] | undefined;
}

export class ThongKeView implements IThongKeView {
    maxViewDay?: number;
    viewedInDay?: number;
    readonly viewConLaiTrongNgay?: number;

    constructor(data?: IThongKeView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.maxViewDay = _data["maxViewDay"];
            this.viewedInDay = _data["viewedInDay"];
            (<any>this).viewConLaiTrongNgay = _data["viewConLaiTrongNgay"];
        }
    }

    static fromJS(data: any): ThongKeView {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maxViewDay"] = this.maxViewDay;
        data["viewedInDay"] = this.viewedInDay;
        data["viewConLaiTrongNgay"] = this.viewConLaiTrongNgay;
        return data;
    }
}

export interface IThongKeView {
    maxViewDay?: number;
    viewedInDay?: number;
    viewConLaiTrongNgay?: number;
}

export class ThongKeViewClick implements IThongKeViewClick {
    click?: number;
    view?: number;

    constructor(data?: IThongKeViewClick) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.click = _data["click"];
            this.view = _data["view"];
        }
    }

    static fromJS(data: any): ThongKeViewClick {
        data = typeof data === 'object' ? data : {};
        let result = new ThongKeViewClick();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["click"] = this.click;
        data["view"] = this.view;
        return data;
    }
}

export interface IThongKeViewClick {
    click?: number;
    view?: number;
}

export class TokenRequest implements ITokenRequest {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: ITokenRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
        }
    }

    static fromJS(data: any): TokenRequest {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        return data;
    }
}

export interface ITokenRequest {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export enum TranSactionType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class UpdateNguon implements IUpdateNguon {
    shortlinkId?: string;
    origin?: string | undefined;
    duphong?: string | undefined;

    constructor(data?: IUpdateNguon) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.shortlinkId = _data["shortlinkId"];
            this.origin = _data["origin"];
            this.duphong = _data["duphong"];
        }
    }

    static fromJS(data: any): UpdateNguon {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNguon();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shortlinkId"] = this.shortlinkId;
        data["origin"] = this.origin;
        data["duphong"] = this.duphong;
        return data;
    }
}

export interface IUpdateNguon {
    shortlinkId?: string;
    origin?: string | undefined;
    duphong?: string | undefined;
}

export class UpdateStatusRequest implements IUpdateStatusRequest {
    type?: number;
    id?: string;
    userId?: string;
    money?: number;

    constructor(data?: IUpdateStatusRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.money = _data["money"];
        }
    }

    static fromJS(data: any): UpdateStatusRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateStatusRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["money"] = this.money;
        return data;
    }
}

export interface IUpdateStatusRequest {
    type?: number;
    id?: string;
    userId?: string;
    money?: number;
}

export class UserDtoInList implements IUserDtoInList {
    id?: string;
    isActive?: boolean;
    dateCreated?: Date;
    lastLoginDate?: Date | undefined;
    balance?: number;
    userTelegram?: string | undefined;
    refCode?: string | undefined;
    agent?: string | undefined;
    origin?: string | undefined;
    originImage?: string | undefined;
    isVerify?: boolean;
    verifyDateTime?: Date | undefined;
    email?: string | undefined;
    userName?: string | undefined;

    constructor(data?: IUserDtoInList) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isActive = _data["isActive"];
            this.dateCreated = _data["dateCreated"] ? new Date(_data["dateCreated"].toString()) : <any>undefined;
            this.lastLoginDate = _data["lastLoginDate"] ? new Date(_data["lastLoginDate"].toString()) : <any>undefined;
            this.balance = _data["balance"];
            this.userTelegram = _data["userTelegram"];
            this.refCode = _data["refCode"];
            this.agent = _data["agent"];
            this.origin = _data["origin"];
            this.originImage = _data["originImage"];
            this.isVerify = _data["isVerify"];
            this.verifyDateTime = _data["verifyDateTime"] ? new Date(_data["verifyDateTime"].toString()) : <any>undefined;
            this.email = _data["email"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): UserDtoInList {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoInList();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isActive"] = this.isActive;
        data["dateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : <any>undefined;
        data["lastLoginDate"] = this.lastLoginDate ? this.lastLoginDate.toISOString() : <any>undefined;
        data["balance"] = this.balance;
        data["userTelegram"] = this.userTelegram;
        data["refCode"] = this.refCode;
        data["agent"] = this.agent;
        data["origin"] = this.origin;
        data["originImage"] = this.originImage;
        data["isVerify"] = this.isVerify;
        data["verifyDateTime"] = this.verifyDateTime ? this.verifyDateTime.toISOString() : <any>undefined;
        data["email"] = this.email;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IUserDtoInList {
    id?: string;
    isActive?: boolean;
    dateCreated?: Date;
    lastLoginDate?: Date | undefined;
    balance?: number;
    userTelegram?: string | undefined;
    refCode?: string | undefined;
    agent?: string | undefined;
    origin?: string | undefined;
    originImage?: string | undefined;
    isVerify?: boolean;
    verifyDateTime?: Date | undefined;
    email?: string | undefined;
    userName?: string | undefined;
}

export class UserDtoInListPagedResult implements IUserDtoInListPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    readonly firstRowOnPage?: number;
    readonly lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: UserDtoInList[] | undefined;

    constructor(data?: IUserDtoInListPagedResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            (<any>this).firstRowOnPage = _data["firstRowOnPage"];
            (<any>this).lastRowOnPage = _data["lastRowOnPage"];
            this.additionalData = _data["additionalData"];
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(UserDtoInList.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserDtoInListPagedResult {
        data = typeof data === 'object' ? data : {};
        let result = new UserDtoInListPagedResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        data["additionalData"] = this.additionalData;
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserDtoInListPagedResult {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
    additionalData?: string | undefined;
    results?: UserDtoInList[] | undefined;
}

export class VerifyOrLockUserRequest implements IVerifyOrLockUserRequest {
    userId?: string;

    constructor(data?: IVerifyOrLockUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): VerifyOrLockUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyOrLockUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IVerifyOrLockUserRequest {
    userId?: string;
}

export class VerifyUserInfo implements IVerifyUserInfo {
    contact?: string | undefined;
    origin?: string | undefined;
    thumnail?: string | undefined;
    isVerify?: boolean;
    readonly isWaitingVerify?: boolean;

    constructor(data?: IVerifyUserInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.contact = _data["contact"];
            this.origin = _data["origin"];
            this.thumnail = _data["thumnail"];
            this.isVerify = _data["isVerify"];
            (<any>this).isWaitingVerify = _data["isWaitingVerify"];
        }
    }

    static fromJS(data: any): VerifyUserInfo {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyUserInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact;
        data["origin"] = this.origin;
        data["thumnail"] = this.thumnail;
        data["isVerify"] = this.isVerify;
        data["isWaitingVerify"] = this.isWaitingVerify;
        return data;
    }
}

export interface IVerifyUserInfo {
    contact?: string | undefined;
    origin?: string | undefined;
    thumnail?: string | undefined;
    isVerify?: boolean;
    isWaitingVerify?: boolean;
}

export class VerifyUserRequest implements IVerifyUserRequest {
    origin?: string | undefined;
    contact?: string | undefined;
    thumbnail?: string | undefined;

    constructor(data?: IVerifyUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.origin = _data["origin"];
            this.contact = _data["contact"];
            this.thumbnail = _data["thumbnail"];
        }
    }

    static fromJS(data: any): VerifyUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["origin"] = this.origin;
        data["contact"] = this.contact;
        data["thumbnail"] = this.thumbnail;
        return data;
    }
}

export interface IVerifyUserRequest {
    origin?: string | undefined;
    contact?: string | undefined;
    thumbnail?: string | undefined;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}